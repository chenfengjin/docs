.. _concepts/contract:

智能合约
========
智能合约是运行在区块链上的一段可以被验证的应用程序。
典型的智能合约由三个部分组成
合约状态变量
合约方法
合约事件

合约状态变量
^^^^^^^^^^^^

合约方法
^^^^^^^^
合约方法是可以调用的
在合约方法中，有一个特殊的方法。这个方法会在合约部署的时候，由合约虚拟机调用。

合约事件
^^^^^^^^
事件机制
在使用超级链的过程中，可能会遇到一些异步的情况：比如执行合约的时候，构造的交易是否合法我们可以实时获知，但具体什么时候真正的被节点打包上链就不一样了。当然还有其他类似的场景，针对这种问题，我们引入了事件订阅机制。
合约执行上下文

订阅的接口十分简单，只有Subscribe一个

.. code-block:: protobuf
    :linenos:

    service EventService {
        rpc Subscribe (SubscribeRequest) returns (stream Event);
    }

其中订阅接口的SubscribeRequest格式如下：

.. code-block:: protobuf
    :linenos:

    message SubscribeRequest {
        SubscribeType type = 1;
        bytes filter = 2;
    }

    enum SubscribeType {
        // 区块事件，payload为BlockFilter
        BLOCK = 0;
    }

请求里的filter用来设置事件过滤参数，是一段序列化的proto对象，因为订阅不同内容需要的参数不尽相同

``BLOCK`` 事件的过滤参数如下：

.. code-block:: protobuf
    :linenos:

    message BlockFilter {
        string bcname = 1;
        BlockRange range = 2;
        bool exclude_tx = 3;
        bool exclude_tx_event = 4;
        string contract = 10;
        string event_name = 11;
        string initiator = 12;
        string auth_require = 13;
        string from_addr = 14;
        string to_addr = 15;
    }

    message BlockRange {
        string start = 1;
        string end = 2;
    }

其中各个字段的说明如下：

- ``bcname`` 链名，必填字段
- ``range`` 指定起始订阅位置和结束位置，如果没有指定则默认从当前最新区块开始，持续订阅。
- ``exclude_tx`` 是否去掉FilteredTransaction数据
- ``exclude_tx_event`` 是否去掉ContractEvent数据
- ``contract`` 匹配合约名字，为空的话匹配所有合约
- ``event_name`` 匹配合约事件名字，为空的话匹配所有合约事件name
- ``initiator`` 匹配交易发起者地址，为空的话匹配所有交易发起者
- ``auth_require`` 匹配交易的auth_require中的任何一个地址，为空匹配所有
- ``from_addr`` 匹配转账发起者地址，为空的话匹配所有转账发起者
- ``to_addr`` 匹配转账接受者地址，为空的匹配所有转账接受者

``BlockRange`` 字段意义：

- 如果 ``start_num`` 和 ``end_num`` 都为空，则表示从当前最新区块开始，持续订阅最新区块。
- 如果 ``start_num`` 为空， ``end_num`` 不为空，则表示从当前最新区块开始，订阅到指定区块，如果``end_num``小与当前区块则什么也不做。
- 如果 ``start_num`` 不为空， ``end_num`` 为空，则从 ``start_num`` 开始持续订阅。
- 如果 ``start_num`` 和 ``end_num`` 都不为空，按照指定区块范围订阅，左闭右开。

.. note::
    需要注意的是过滤字段都是正则表达式，如果需要全匹配名字为 ``counter`` 的合约，``contract`` 字段需要为 ``^counter$`` ，
    不能为 ``counter`` ，这么写会匹配到名为 ``counter1`` 的合约。

订阅返回的内容格式均为Event，事件的详细内容会放在payload里

.. code-block:: protobuf
    :linenos:

    message Event {
        bytes payload = 1;
    }

订阅 ``BLOCK`` 事件时，填充如下内容:

.. code-block:: protobuf
    :linenos:

    message ContractEvent {
        string contract = 1;
        string name = 2;
        bytes body = 3;
    }

    message FilteredTransaction {
        string txid = 1;
        repeated ContractEvent events = 2;
    }

    message FilteredBlock {
        string bcname = 1;
        string blockid = 2;
        int64 block_height = 3;
        repeated FilteredTransaction txs = 4;
    }


当然，订阅RPC接口断开的时候，订阅行为也会停止

系统合约与用户合约
--------
XuperChain 支持不同的权限等级。在 内部设计了Ring0 到Ring4 四个权限级别。
xxxxx
系统合约运行在权限最高Ring0 级别，用户合约运行在Ring4 级别。
XuperChain 通过系统合约来实现合约部署/合约升级/等功能。

实名？？ 封禁??

合约权限
--------
XuperChain 支持完整的丰富的权限模型，整体氛围合约虚拟机/合约XX/合约方法三个层的
在合约虚拟机层
在合约数据层??
合约账号层
在合约账号方面，超级链采用 XXXXX 模型，一个合约账号由多个外部账号控制和管理，支持 XXXXX 等权限模型
    1
    2
    3
    4
    5

在合约方法层，支持设置合约方法 ACL, 只允许特定地址进行合约方法调用(????)

合约虚拟机
----------
合约虚拟机负责合约的执行。XuperChain 通过 XuperBridge(加链接) 技术实现 合约状态数据与合约代码运行环境分离，从而能够支持多语言虚拟机且各种合约虚拟机只需要做纯粹的无状态合约代码执行；
，合约执行上下文保存合约执行的状态，虚拟机负责无状态的合约代码的执行。
合约语言

合约运行时
----------
XuperChain  自研了一套 EVM 虚拟机，支持不同的合约开发语言和合约运行时。
在合约开发语言方面，当前既然支持 solidity 等合约专用语言，也支持 c++ go java  等通用语言(TODO，用词 + 链接)作合约开发语言。

XuperChain 支持不同的合约运行时。
完整的语言-运行时矩阵见 YYYY

    这里的目标是解释清楚几个问题： 这些合约运行时是什么? 这些运行时各有什么优缺点，如何选择合适的合约运行时？

Native
    Native 合约 xxxxx
WASM
    WASM 合约 xxx
EVM
   EVM 合约 XXX
   关于evm 合约更多信息可以查看 在 XuperChain 上部署 以太坊合约

合约调用

跨合约调用
